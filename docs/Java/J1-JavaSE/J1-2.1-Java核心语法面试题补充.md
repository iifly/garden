# Java核心语法面试题补充

### 数据类型
#### 自动类型转换、强制类型转换

Java 所有的**数值型变量**可以相互转换。
- 把一个**表数范围小**的数值或变量赋给另一个**表数范围大**的变量时，可以进行**自动类型转换**
- 反之，需要**强制转换**！

![Java自动类型转换方向.png](/imgs/Java自动类型转换方向.png)

#### 基本数据类型和引用数据类型

- 基本数据类型
	- 变量指向具体的数值
	- 基本数据类型存储在栈上

- 引用数据类型
	- 变量指向的是存储对象的内存地址，在栈上
	- 内存地址指向的对象存储在堆上

#### 基本数据类型有什么好处?

在 Java 语言中，`new` 一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象，对象本身是比较消耗资源的。

对于经常用到的类型，如 `int` 等，如果我们每次使用这种变量的时候都需要 `new` 一个 Java 对象的话，就会比较笨重。

所以，和 C++ 一样，Java 提供了基本数据类型，这种数据的变量不需要使用 `new` 创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。

#### 包装类型
##### 包装类型是什么？为什么需要包装类？
Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便。

> 比如，在集合类中，我们是无法将 `int` 、`double` 等类型放进去的。

为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为**包装类(Wrapper Class)**，

包装类具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

包装类均位于 `java.lang` 包，包装类和基本数据类型的对应关系如下表所示

![基本数据类型与包装类型](imgs/基本数据类型与包装类型.png)

在这八个类名中，除了 `Integer` 和 `Character` 类，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。

> 包装类都为`final `不可继承

##### 拆箱与装箱？

有了基本数据类型和包装类，肯定需要在他们之间进行转换。

比如把一个基本数据类型的 `int` 转换成一个包装类型的 `Integer` 对象。

- 把**基本数据类型 转换成 包装类**的过程就是打包装，英文对应于 *boxing*，中文翻译为装箱。
- 把**包装类 转换成 基本数据类型**的过程就是拆包装，英文对应于 *unboxing*，中文翻译为拆箱。

在 *Java SE5* 之前，要进行装箱，可以通过以下代码：

```
    Integer i = new Integer(10);
```

在 *Java SE5* 中，为了减少开发人员的工作，Java 提供了**自动拆箱与自动装箱**功能。

- 自动装箱：就是将基本数据类型**自动转换**成对应的包装类。
- 自动拆箱：就是将包装类**自动转换**成对应的基本数据类型。

```
    Integer i = 10;  //自动装箱
    int b = i;     //自动拆箱
```

`Integer i = 10;` 可以替代 `Integer i = new Integer(10);`，这就是因为 Java 帮我们提供了自动装箱的功能，不需要开发者手动去 `new` 一个 `Integer` 对象。

##### 自动拆/装箱带来的问题

自动拆装箱是一个很好的功能，大大节省了开发人员的精力，但也会引入一些问题：

- 包装对象的数值比较，不能简单的使用 `==`，虽然 -128 到 127 之间的数字可以，但是这个范围之外还是需要使用 `equals` 比较。
- 自动拆箱时如果包装类对象为 `null` ，那么自动拆箱时就有可能抛出 `NPE`。
 - 如果一个 `for` 循环中有大量拆装箱操作，会浪费很多资源。

##### 缓存池

包装类型内使用 `private static class XxxCache`，声明一个内部使用的缓存池。

如 `Integer` 中有个静态内部类 `IntegerCache`，里面有个`cache[]`,也就是 `Integer` 常量池。

`Byte`、 `Short`、`Long`缓存范围：`-128 ~ 127`，`Character`：缓存范围是 `0 ~ 127`，除了`Integer`以外，这个范围都不能改变。

 > 在 *jdk 1.8* 所有的数值类缓存池中，`Integer` 的缓存池 `IntegerCache` 很特殊，它下界是 `- 128`，上界默认是 `127`，但是，在启动 jvm 的时候，可以通过 `-XX:AutoBoxCacheMax=size` 来指定这个缓冲池的上界大小，最终会取 `127` 与  `size` 较大者，这个缓存会在 `Integer` 类第一次被使用的时候被初始化出来。

### 对象比较

#### Integer a= 127, b = 127;Integer c= 128, d = 128;相等吗?

```java
 public static void main(String[] args) {  
	 Integer a = 127; // 自动装箱 去缓存池里取 Integer 对象
	 Integer b = 127; // 自动装箱 去缓存池里取 Integer 对象
	 Integer b1 = new Integer(127); // 用 new 创建对象存储在堆上
	 System.out.println(a == b); //true 都是缓存池的同一个对象
	 System.out.println(b == b1); //false 一个是缓存池对象，一个是堆上的对象
	  
	 Integer c = 128; // 自动装箱,超过缓存池范围，new 一个新的对象
	 Integer d = 128; // 自动装箱,超过缓存池范围，new 一个新的对象 
	 System.out.println(c == d); //false 堆上不同的对象
 }
```

`Integer a = 127`这种赋值，是用到了 `Integer` 自动装箱的机制。自动装箱的时候会去缓存池里取 `Integer` 对象，没有取到才会创建新的对象。

如果整型字面量的值在`-128 ~ 127`之间，那么自动装箱时不会 `new` 新的 `Integer` 对象，而是直接引用缓存池中的 `Integer` 对象，超过范围 `a1 == b1`的结果是 `false`

#### 对象相等与引用相等，两者有什么不同？

- 对象相等 比的是内存中存放的**内容**是否相等
- 引用相等 比较的是他们指向的**内存地址**是否相等

#### == 与 equals

- `==` 
	- 对于基本数据类型 `==` 比较的是值是否相等。
	- 对于引用数据类型 `==` 比较的是内存地址，即，**判断两个对象是不是同一个对象**。

- `equals()`  它的作用也是**判断两个对象是否相等**。但它一般有两种使用情况：
	-   情况 1：类没有重写 `equals()` 方法。则通过 `equals()` 比较该类的两个对象时，等价于通过 `==` 比较这两个对象，还是相当于比较内存地址。
	-   情况 2：类重写了 `equals()` 方法。相当于自定义了一个衡量对象是否相等的标准，一般就是比较两个对象各属性的值是否相等。

#### 为什么重写 equals 时必须重写 hashCode 方法？

Java 中对 `hashCode()` 与 `equals()` 有如下规定
- 调用 `equals` 方法判断两个对象是否相等，相等则返回 `true` 
- 如果两个对象相等，则 `hashcode` 一定也是相同的
- 具有相同的 `hashcode` 值的两个对象不一定相等

**因此，equals 方法被重写过，则 hashCode 方法也必须被重写，使得相等的对象返回 hashCode 一致**

#### 为什么具有相同的 `hashcode` 值的两个对象不一定相等？

因为可能会**碰撞**， `hashCode()` 所使⽤的散列算法也许刚好会让多个对象传回相同的散列值。
越糟糕的散列算法越容易碰撞，但这也与数据值域分布的特性有关

> 所谓碰撞也就是指的是不同的对象得到相同的 `hashCode` 。

### 变量
#### 成员变量与局部变量的区别有哪些？

1.  **从语法形式上看**：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 `public` , `private` , `static` 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。 
2.  **从变量在内存中的存储⽅式来看**：如果成员变量是使⽤ `static` 修饰的，那么这个成员变量是属于类的，如果没有使⽤ `static` 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。
3.  **从变量在内存中的⽣存时间上看**：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。
4.  **成员变量如果没有被赋初值**：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 [final](#final关键字有什么作用？) 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。

#### 静态变量和实例变量的区别？静态⽅法和实例⽅法有何不同?

**静态变量:** 是被 `static` 修饰符修饰的变量，也称为**类变量**，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中**有且仅有一个副本**。

**实例变量:** 必须**依存于某一实例**，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

**静态方法**：`static` 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤"**类名.⽅法名**"的⽅式，也可以使⽤"**对象名.⽅法名**"的⽅式。**静态方法里不能访问类的非静态成员变量和方法。**

**实例⽅法**：依存于类的实例，需要使用"**对象名.⽅法名**"的⽅式调用；可以访问类的静态和非静态变量和方法。

#### 在一个静态方法内调用一个非静态成员为什么是非法的？

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### final 关键字

#### final关键字有什么作用？

final 表示不可变的意思，可用于修饰类、属性和方法：
-   被 `final` 修饰的类不可以被继承  
-   被 `final` 修饰的方法不可以被重写
-   被 `final` 修饰的变量不可变，被 `final` 修饰的变量**必须被显式第指定初始值**，
> 注意，这里的不可变指的是**变量的引用不可变**，引用指向的内容是可变的。

#### final、finally、finalize 的区别？

-   `final` 用于修饰变量、方法和类：`final` 修饰的类不可被继承；修饰的方法不可被重写；修饰的变量不可变。
-   `finally` 作为异常处理的一部分，它只能在 `try/catch` 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，`System.exit (0)` 可以阻断 `finally` 执行。
-   `finalize` 是在 `java.lang.Object` 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 `gc` 启动，该对象被回收的时候被调用。
    
> 一个对象的 `finalize` 方法只会被调用一次，`finalize` 被调用不一定会立即回收该对象，有可能调用 `finalize` 后，对象又不需要被回收，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 `finalize` 了，进而产生问题，因此不推荐使用 `finalize` 方法。


### String

#### String 是 Java [基本数据类型](docs/Java/J1-JavaSE/J1-2-Java核心语法.md#基本数据类型) 吗？

**不是**。`String` 是一个比较特殊的引用数据类型。

>Java 中的基本数据类型只有 8 个：`byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean`；
除了基本类型（primitive type），剩下的都是引用类型（reference type）。

#### 字符型常量和字符串常量的区别

-   形式上: 字符常量是**单引号**引起的**一个字符**；字符串常量是**双引号**引起的**若干个字符**
-   含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)  
-   占内存大小：字符常量只占 2 个字节；字符串常量占若干个字节

#### String 的不可变性？

> **不可变对象**是在完全创建后**其内部状态保持不变的对象**。这意味着，一旦对象被赋值给变量，我们**既不能更新引用，也不能通过任何方式改变内部状态**。

- `String` 类使用 `final` 修饰，是所谓的不可变类，无法被继承。
- `String` 类中保存字符串的字符数组使用 `final` 关键字修饰，`private final char value[]`，所以 `String` 对象是不可变的。
-  `String` 的每次改变其实都是生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象，并不是改变原来的值。

>Tip：在 *Java 9* 之后，`String` 、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串 `private final byte[] value` 

#### 为什么String要设计成不可变

-   **节省空间**：字符串常量存储在 JVM 的 [字符串池](#什么是字符串常量池?) 中可以被用户共享。
-   **提高效率**：`String` 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
-   **安全**：`String` 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。

#### String str = "a"和String str = String("a")有什么区别？

 - `String str = "a"` 可能创建 0 个或 1 个对象。
	1. 如果 Java 字符串常量池中已经存在字符串 `"a"` ， `str` 引用变量指向其地址给即可，不必创建对象。
	2. 否则，先在字符串常量池中创建一个字符串 `"a"` ，再使 `str` 引用变量指向其地址，创建 1 个对象。

- `String str = new String("a")` 可能创建 1 个或 2 个对象。
	1. 因为用到 `new` 关键字，肯定会在堆中创建一个 `String` 对象，使 `str` 引用变量指向这个 `String` 对象地址。
	2. 然后和上面一样，如果 Java 字符串常量池中已经存在字符串 `"a"`，使堆上创建的 `String` 对象指向其地址，总共创建 1 个对象。
	3. 否则，先在字符串常量池中创建一个字符串 `"a"` 对象，再使堆上创建的 `String` 对象指向其地址，总共创建 2 个对象。

##### 我的理解
> - 使用 `new` 创建字符串时，引用变量指向的是堆中的 `String` 对象，堆中的 `String` 对象再指向**字符串常量池**中字符串地址。
> - 反之，引用变量直接指向**字符串常量池**中字符串地址。

#### 什么是字符串常量池?

**字符串常量池**是专门用来存储**字符串常量**的一块**堆**内存，可以提高内存的使用率，避免开辟多块空间存储相同的字符串。

在创建字符串时 JVM 会首先检查字符串常量池，如果字符串已经存在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串放到池中并把当前引用指向该字符串。

> [常量池内存位置演化](https://cloud.tencent.com/developer/article/1690589)

#### String 和 StringBuilder、StringBuffer 的区别？

- `String` 中的对象是不可变的，也就可以理解为常量，线程安全，每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。——*适用于操作少量的数据*

- `StringBuilder` 进行改变的时候也是操作对象本身，但并没有对方法进行加同步锁，所以是非线程安全的。——*适用于单线程操作字符串缓冲区下操作大量数据*
- 
- `StringBuffer` 进行改变的时候是操作对象本身，并且方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的，可理解为线程安全的 `StringBuilder` ——*适用于多线程操作字符串缓冲区下操作大量数据*

#### 数组有没有 length() 方法? String有没有 length() 方法?
- 数组没有 `length()` 方法,有 `length` 的属性。
- `String` 有 `length()` 方法。

> JavaScript 中,获得字符串的长度是通过 `length` 属性得到的，这一点容易和 Java 混淆。

#### intern 方法有什么作用？

返回字符串常量池中与之内容相等的对象引用
-   如果字符串常量池已经存在当前字符串（即 `equals() `方法为 `true`），直接返回字符串常量池中的字符串对象的引用
-   否则，将此 `String` 对象添加到字符串常量池中，再返回**池中** `String` 对象的引用

#### String有没有长度限制？

**字符串有长度限制！**
- 在编译期，要求字符串常量池中的常量不能超过 `65535`，在 `javac` 执行过程中控制了最大值为 `65534`。
- 在运行期，长度不能超过 `Integer.MAX_VALUE` 的范围，否则会抛异常。

### 运算小记

#### 用最有效率的方法计算 2 乘以 8？

`2 << 3`。**位运算**。（数字的二进制位*左移三位*相当于*乘以 2 的三次方*）

> - 左移 n 位相当于乘以 2 的 n 次方；
> - 右移 n 位相当于除以 2 的 n 次方（如果不能整除则向下取整）。
> - 只有整型和字符型可以使用位运算。

#### Math.round(11.5) 等于多少？Math.round(-11.5)等于多少

`Math.round(11.5)` 的返回值是 `12`，`Math.round(-11.5)` 的返回值是`-11`。

> 四舍五入的原理是在参数上加 `0.5` 然后进**向下取整**。
> eg: `Math.round(-11.6)` 的返回值是`-12`，相当于 `-11.6 + 0.5 = -11.1` 向下取整等于 `-12`

#### &和&&有什么区别？

- `&`  *逻辑与*  —— 要求运算符`左右两端`的布尔值都是 `true` 整个表达式的值才是 `true`。
- `&&`  *短路与* —— `左边`的表达式的值是 `false`，则直接返回 `false`，右边的表达式会被直接短路掉，不会进行运算。

> **注意**：*逻辑或* `|` 和 *短路或* `||` 的区别也是如此。
