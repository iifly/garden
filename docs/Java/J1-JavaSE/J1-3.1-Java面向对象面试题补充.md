# Java面向对象面试题补充

### ⾯向对象和⾯向过程
- 面向过程
	- 概念：一种以**过程为中心**的编程思想，它把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可！很明确的可以看出第一步做什么、第二步做什么。
	- 优点：性能高
	- 应用场景：比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
	- 缺点：代码重用性低，扩展能力差，后期维护难度比较大

- 面向对象
	- 概念：一种以**对象为核心**的编程思想，通过对现实世界的理解和抽象，将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。
	- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
	- 缺点：性能比面向过程低

> 面向对象的底层其实还是面向过程，把面向过程抽象成类，方便我们使用的就是面向对象了。


### 静态多态

- 很多人认为 Java 中**重载**是一种**静态多态**，因为重载需要在**编译期决定具体调用哪个方法**。

### 构造器 Constructor 是否可被 override?

- `Constructor` 不能被 `override`（重写）,但是可以 `overload`（重载）,所以一个类中可以有多个构造函数。

### 重载和重写

#### 重载
- 场景：发生同一个类中
- 要求：方法名称相同，参数列表不同(参数个数、参数类型、参数顺序)，方法返回值和访问修饰符可以不同
- 发生阶段：编译期
#### 重写
- 场景：如果父类的方法无法满足子类的使用，那么子类可以使用同名方法覆盖父类方法
- 要求：方法名、参数列表、返回值类型相同，访问修饰符不能比父类的权限小，抛出异常范围不能比父类大
- 发生阶段：运行期
- 规范：重写的方法用注解 `@Override` 标识

#### 注意

- 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法
- 但是被 `static` 修饰的方法，子类能够被**再次声明**，这**并不是重写**，当调用此方法时，变量的引用类型是谁，调用的就是谁声明的方法。

### this与super的区别

#### this关键字的用法

`this` 是自身的一个对象，代表对象本身，可以理解为：**指向对象本身的一个指针**。

`this` 的用法在 Java 中大体可以分为3种：

1. 普通的直接引用，`this` 相当于是指向当前对象本身。
2. 形参与成员名字重名，用 `this` 来区分：
3. 调用本类中另一种形式的构造函数，`this(参数)`（应该为构造函数中的第一条语句）

#### super关键字的用法

`super` 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。

`super` 也有三种用法：

1. 普通的直接引用
与 `this` 类似，`super` 相当于是指向当前对象的父类的引用，这样就可以用 `super.xxx` 来引用父类的成员。
2. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用 `super` 进行区分  
3. 调用父类中的某一个构造函数 `super(参数)`（应该为构造函数中的第一条语句）。

> 注意： 
> -   `super()` 和 `this()` 必须是构造方法的第一句语句。所以 `super()` 和 `this()` 不能同时出现在一个构造函数里面（不能满足两个语句都是第一句）。
> -   `this` 和 `super` 都指的是对象，所以，均不可以在 `static` 环境中使用。


### 值传递和引用传递有什么区别? Java 到底是值传递还是引用传递? 
- 答：**值传递**，**Java 语言的方法调用只支持参数的值传递**。

当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用。对象的属性可以在被调用过程中被改变，但对象引用的改变是不会影响到调用者的。


#### 值传递

指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是**值的拷贝**，也就是说传递后就互不相关了。

#### 引用传递

指的是在方法调用时，传递的参数是按引用进行传递，其实传递的**引用的地址**，也就是变量所对应的内存的地址，传递后我们可以改变地址空间里的内容，但不会改变地址本身。

### 浅拷贝和深拷贝

-   **浅拷贝**：仅拷贝对象的成员变量的值——基本数据类型变量的值和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝，引用变量还是指向堆中原来的对象。
-   **深拷贝**：完全拷贝一个对象，不仅拷贝对象的成员变量的值，堆中的对象也会拷贝一份，引用变量指向堆中拷贝的新对象。

例如现在有一个 order 对象，里面有一个 products 列表，它的浅拷贝和深拷贝的示意图：

![浅拷贝和深拷贝示意图.png](/imgs/浅拷贝和深拷贝示意图.png)

因此深拷贝是安全的，浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象。